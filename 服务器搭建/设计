
说明：
1. 所有的任务都在DB中进行保存
2. 任务池中不存储所有任务，只是存储所有任务的不同时间，将时间作为结点存储。可大大减少内存的使用，并可提高任务池操作效率
3. 任务池使用红黑树作为存储结构。算法网上有，好像libevent库也是使用红黑树，可以参考。
4. 任务池建议预分配内存空间，以提高性能，并规避运行期间可能分配失败的情况。
5. 任务池为一块连续内存。这个我的建议是先预估结点最大个数，预分配其两倍大小的内存。使用哈希来处理它的存储位置问题，再组织成红黑树



main()
{
  预分配所需要的全局存储内存，包括任务池；
	打开DB；
	读取DB中原有任务，获取所有不同的时间，构造内存任务池；

	创建来自客户端的新任务缓冲区RecBuf1；
	初始化RecBuf1的写入游标，读出游标；

	启动epoll接收线程Thread1；
	启动事件存储线程Thread2；
	启动事件触发线程Thread3；
}

Thread1
{
	创建epoll，并以ET方式设置（这个网上很多例子，不详述）
	
	将接收的数据顺序插入到缓冲区RecBuf1,移动写入游标
	
}

Thread2
{
	for(;;)
	{//一次性读完所有缓存中的数据，再等待
		if(读游标位置有数据)
		{
			读取一条任务；
			解析任务，获得任务类型，以及时间；
			if(新增任务)
			{
				以时间为key，二分查找当前任务池中有无此时间的结点，
				if(无此时间结点)
				{
          以时间为hash key，找到在任务池中的存储位置。将此时间结点插入到任务池
					重新构造红黑树结构
				}
				将此任务完整信息插入到DB；
			}
			else if(删除任务)
			{
				以任务id为条件，检索DB，将此任务删除；
				以此任务时间为条件，检索DB，如果此时间不存在任务，则从任务池中删除此时间结点；
			}
			else if(查询任务)
			{
				根据条件到DB中检索事件，发回客户端；
			}
			else
			{
				向客户端返回错误信息；
			}
		}			
		else
		{
			sleep(1);
		}
	}
}

Thread3()
{
  //因为任务池用红黑树设计，前面几条语句执行速度会非常快，所以，sleep 1秒已经是很长的时间了，根据我的经验，不会给性能造成明显的影响。你可以验证
  //另外循环读取红黑树是为了可以当新的任务加到任务池中时，可以更新为新的最近任务
  //检索DB可以放在if语句外面，这样可以增加报时的准确性，却要降低一点系统的性能，因为每次循环都要读一次。你可以看情况选择
  for(;;)
  {
	  从任务池中读取第一个时间结点（离当前最近的时间点）
	  读取系统当前时间；
	  if(时间结点时间<=当前时间)
	  {
		  以节点时间为条件，检索DB，读出所有此时间点的任务；
		  for(i=0;i<=当前时间点任务数;i++)
		  {
			  //还没要设计好
		  }
	  }
    sleep(1);
  }
}





